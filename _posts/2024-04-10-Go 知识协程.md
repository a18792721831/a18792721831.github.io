---
layout: post
title: Go 知识协程
categories: [go]
description: Go 知识协程
keywords: golang, go, go协程, go协程调度模型, go协程调度策略
---

Go 知识协程

# 1. 基本概念
协程是Go语言最大的特色之一，也是将协程支持的非常优雅的实现，Go在语言层面直接提供对协程的支持。
## 1.1 进程
进程是应用程序的启动实例，每个进程都有独立的内存空间，不同进程通过进程间的通信方式来通信。
## 1.2 线程
线程从属于进程，每个进程至少包含一个线程，线程是CPU调度的基本单位，多个线程之间可以共享进程的资源并通过共享内存等线程间的通信方式来通信。
## 1.3 协程
协程可理解为一种轻量级的线程，与线程相比，协程不受操作系统调度，协程调度器由用户应用程序提供，协程调度器按照调度策略把协程调度到线程中运行。
Go应用程序的协程调度器由runtime包提供，用户使用go关键字即可创建协程，这也就是在语言层面直接支持协程的含义。
# 2. 协程的优势
在高并发应用中频繁创建线程会造成不必要的开销，所以有了线程池技术。在线程池中预先保存一定数量的线程，新任务将不再以创建线程的方式去执行，
而是将任务发布到任务队列中，线程池中的线程不断地从任务队列中取出任务并执行，这样可以有效地减少线程的创建和销毁带来的开销。  

![img.png](/images/posts/2024-04-10-Go%20知识协程/img.png)

任务队列中的每一个任务成为G,而G往往代表一个函数。线程池中的worker线程不断地从任务队列中取出任务并执行，而worker现成则交给操作系统进行调度。  
如果worker线程执行的G任务中发生系统调用，那么操作系统会将该线程置为阻塞状态，这也就意味着该线程在摸鱼儿，由于消费任务队列中的worker线程变少了，所以线程池消费任务的能力变弱了。  
如果任务队列中的大部分任务都进行系统调用，则会让这中间状态恶化，大部分worker线程进入阻塞状态，从而任务队列中的任务产生堆积。  
解决这个问题的一个思路就是重新审视线程池中线程的数量，增加线程池中的线程数量可以在一定程度上提高消费能力，但随着线程数量增多，过多线程争抢CPU资源，消费能力会有上限，甚至出现消费能力下降的现象。
> 一般服从正态分布。

过多的线程会导致上下文切换的开销变大，而工作在用户态的协程则能大大减小上下文切换的开销。协程调度器把可运行的协程逐个调度到线程中执行，
同时及时把阻塞的协程调度出线程，从而有效地避免了线程的频繁切换，达到使用少量线程实现高并发的效果。  
多个协程分享操作系统分给线程的时间片，从而达到充分利用CPBU算力的目的，协程调度器则决定了协程运行的顺序。  

![img_1.png](/images/posts/2024-04-10-Go%20知识协程/img_1.png)

# 3. 调度模型
## 3.1 线程模型
线程可分为用户线程和内核线程，用户线程由用户创建、同步和销毁，内核线程则由内核来管理。根据用户线程管理方式的不同，分为三种线程模型。
- N:1 模型：N个用户线程运行在一个内核线程中，优点是用户线程上下文切换快，缺点是无法充分利用多核CPU的算力。
- 1:1 模型：每个用户线程对应一个内核线程，优点是充分利用CPU的算力，缺点是线程上下文切换较慢。
- M:N 模型：M个用户线程(协程)运行在N个线程中，优点是充分利用CPU的算力，并且上下文切换快；缺点是该模型的调度算法复杂。

> Go语言使用的是M:N模型。

## 3.2 Go调度器模型
Go协程调度器模型中包含三个关键实体，machine(M),processor(P)和goroutine(G)。    

![img_2.png](/images/posts/2024-04-10-Go%20知识协程/img_2.png)

- M(machine): 工作线程，由操作系统调度。
- P(processor): 处理器(Go定义的一个概念，不是指CPU)，包含运行Go代码的必要资源，也有调度goroutine的能力。
- G(goroutine): Go协程，每个go关键字都会创建一个协程。

M必须持有P才可以执行代码，和系统中的其他线程一样，M也会被系统调度阻塞。P的个数在程序启动时决定，默认情况下等于CPU的核数，可以使用环境变量`GOMAXPROCS`
或在程序中使用`runtime.GOMAXPROCS()`方法指定P的个数。  
M的个数通常稍大于P的个数，因为除了运行Go代码，runtime包还有其他内置任务需要处理。  

![img_3.png](/images/posts/2024-04-10-Go%20知识协程/img_3.png)

上图中包括两个工作线程M，每个M持有一个处理器P，并且每个M中有一个协程G在运行。其他的协程正在等待被调度，位于被称为runqueues的队列中。
每个处理器P中有一个runqueues队列，此外还有一个全局的runqueues队列，由多个处理器共享。  
早期的调度器实现中(Go 1.1 之前)只包含全局的runqueues，多个处理器P通过互斥锁来调度队列中的协程，在多CPU或多核环境中，多个处理器需要经常争抢锁来调度全局队列中的协程，严重影响了并发执行效率。
后来引入了局部的runqueues，每个处理器P访问自己的runqueues时不需要加锁，大大提高了效率。  
一般来说，处理器P中的协程G额外在创建的协程会加入本地的runqueues中，但如果本地的队列已满，或者阻塞的协程被唤醒，则协程会被放入全局的runqueues中，处理器P除了调度本地的runqueues中的协程，还会周期性地从全局runqueues中摘取协程来调度。
# 4. 调度策略
Go 协程调度器也是不断演进的，使得Go支持越来越多的调度策略，以便在不同的应用场景下都能产生优异的并发效果。
## 4.1 队列轮转
每个处理器P维护者一个协程G的队列，处理器P依次将协程G调度到M中执行。  
协程G执行结束后，处理器P会再次调度一个协程G到M中执行。  
同时，每个P会周期性地查看全局队列中是否有G待运行并将其调度到M中执行，全局队列中的G主要来自从系统调用中恢复的G。之所以P会周期性地查看全局队列，也是为了防止全局队列中的G长时间得不到调度机会而长时间等待。
## 4.2 系统调用
当线程在执行系统调用时，可能会被阻塞，对应到调度器模型，如果一个协程发起系统调度，那么对应的工作线程会被阻塞，这样依赖，处理器P的runqueues队列中的协程将得不到调度，相当于队列中的所有协程都被阻塞。  
前面提到P的个数默认等于CPU的核数，每个M必须持有一个P才能执行G。一般情况下M的个数会略大于P的个数，多出来的M将会在G产生系统调用时发挥作用。与线程池类型，Go也有一个M的池子，需要时从池子中获取，用完放回池子，不够用就在创建一个。  

![img_4.png](/images/posts/2024-04-10-Go%20知识协程/img_4.png)

当G0即将进入系统调用时，M0将释放P，进而M1获取P，继续执行P队列中剩下的G。M0由于陷入系统调用而被阻塞，M1接替M0的工作，只要P不空闲，就可以继续使用CPU。  

![img_5.png](/images/posts/2024-04-10-Go%20知识协程/img_5.png)

冗余的M的来源有可能是缓存池，也有可能是新建的。当G0结束系统调用后，根据M0是否能获取到P，对G0进行不同的处理：
- 如果有空闲的P，则获取一个P，继续执行G0
- 如果没有空闲的P，则将G0放入全局队列，等待被其他的P调度。然后M0将进入到缓存池睡眠

## 4.3 工作量窃取
通过go关键字创建的协程通常会优先放到当前协程对应的处理器队列中，可能有些协程自身不断地派生新的协程，而有些协程不派生协程。这样的话，多个处理器P中维护的G队列有可能是不均衡的，如果不加以控制，则有可能出现部分处理器P非常繁忙，而部分处理器P空闲的情况。  
为此，Go调度器提供了工作量窃取策略，即当某个处理器P没有需要调度的协程时，将从其他处理器中偷取协程。  

![img_6.png](/images/posts/2024-04-10-Go%20知识协程/img_6.png)

上面的图中，右边的处理器P空闲，当全局队列中也没有协程需要调度，将从左边的处理器的runqueues中偷取一半的协程。  

![img_7.png](/images/posts/2024-04-10-Go%20知识协程/img_7.png)

## 4.4 抢占式调度
抢占式调度，是指避免某个协程长时间执行，阻碍其他协程被调度。  
调度器会监控每个协程的执行时间，一旦执行时间过长且有其他协程在等待执行时，会把写成暂停，转而调度等待的协程，已达到类似于时间片轮转的效果。  
在Go 1.14 之前，Go 协程调度器抢占式调度机制有局限性，在设计中，是在函数调用间隙检查协程是否可被抢占，如果协程没有函数调用，则会无限期占用执行权：
```Go
package main

import (
    "fmt"
    "runtime"
    "time"
)

func main() {
   	// 设置只有一个处理器
	runtime.GOMAXPROCS(1)
	go func() {
		for {
			// 无函数调用的无限循环
		}
	}()
	// 系统调用，让出执行权
	time.Sleep(1 * time.Second)
	fmt.Println("xx")
}
```
运行超时了  

![img_8.png](/images/posts/2024-04-10-Go%20知识协程/img_8.png)

如果在1.14和之后的Go中执行：  

![img_9.png](/images/posts/2024-04-10-Go%20知识协程/img_9.png)

在Go 1.14 中，调度器引入了基于信号的抢占式机制，这个问题才解决了。
# 5. GOMAXPROCS对性能的影响
程序运行时就将GOMAXPROCS的大小设置为CPU的核数，可让Go程序充分利用CPU。在某些I/O密集型的应用中，这个值可能并不意味着性能最好。
理论上当某个goroutine进入系统调用时，会有一个新的M被启用或创建，继续占用CPU。但由于Go调度器检测到M被阻塞是有一定延迟的，即旧的M被阻塞和新的M得到运行之间是有一定时间间隔的，
所以在I/O密集型应用中可以把GOMAXPROCS的值设置的大一些，或许性能能好一些。  

